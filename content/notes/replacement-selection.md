---
title: 'Replacement Selection'
date: 2024-02-14T01:48:15+08:00
draft: false
categories: 
tags: # 自由新增
    - FDS Homework
isCJKLanguage: true # 是否是中文(chinese,japanese,korea) 字數判斷用
comments: true
showToc: true # 顯示目錄
TocOpen: true # 預設打開目錄
hidemeta: false # 是否隱藏meta訊息(ex:發布日期、作者...etc)
disableShare: false # 取消社群分享區塊
showbreadcrumbs: true # 於頂部顯示文章路徑
ShowWordCounts: true
ShowReadingTime: true
ShowLastMod: true
---
# 7-1 Replacement Selection
When the input is much too large to fit into memory, we have to do **external sorting** instead of internal sorting. One of the key steps in external sorting is to generate sets of sorted records (also called runs) with limited internal memory. The simplest method is to read as many records as possible into the memory, and sort them internally, then write the resulting run back to some tape. The size of each run is the same as the capacity of the internal memory.  
**Replacement Selection** sorting algorithm was described in 1965 by Donald Knuth. Notice that as soon as the first record is written to an output tape, the memory it used becomes available for another record. Assume that we are sorting in ascending order, if the next record is not smaller than the record we have just output, then it can be included in the run.  
For example, suppose that we have a set of input { 81, 94, 11, 96, 12, 99, 35 }, and our memory can sort 3 records only. By the simplest method we will obtain three runs: { 11, 81, 94 }, { 12, 96, 99 } and { 35 }. According to the replacement selection algorithm, we would read and sort the first 3 records { 81, 94, 11 } and output 11 as the smallest one. Then one space is available so 96 is read in and will join the first run since it is larger than 11. Now we have { 81, 94, 96 }. After 81 is out, 12 comes in but it must belong to the next run since it is smaller than 81. Hence we have { 94, 96, 12 } where 12 will stay since it belongs to the next run. When 94 is out and 99 is in, since 99 is larger than 94, it must belong to the **first run**. Eventually we will obtain two runs: the first one contains { 11, 81, 94, 96, 99 } and the second one contains { 12, 35 }.  
Your job is to implement this replacement selection algorithm.
## Input Specification:
Each input file contains several test cases. The first line gives two positive integers N (≤10<sup>5</sup>) and M (<N/2), which are the total number of records to be sorted, and the capacity of the internal memory. Then N numbers are given in the next line, all in the range of **int**. All the numbers in a line are separated by a space.
## Output Specification:
For each test case, print in each line a run (in ascending order) generated by the replacement selection algorithm. All the numbers in a line must be separated by exactly 1 space, and there must be no extra space at the beginning or the end of the line.
## Sample Input:
```
13 3
81 94 11 96 12 99 17 35 28 58 41 75 15
```
## Sample Output:
```
11 81 94 96 99
12 17 28 35 41 58 75
15
```
## Code
```c
#include <stdio.h>
#include <stdlib.h>

#define MAXN 500000

typedef enum Boolean{FALSE, TRUE} Boolean ;
typedef int DataValue ;
typedef struct Heap{
  DataValue nodes[MAXN];
  int size;
}Heap;

Heap* heap_init(){
  Heap* res = (Heap*)malloc(sizeof(Heap));
  res->size = 0;
  return res;
};
void heap_delete(Heap* heap){
  if(heap==NULL) return;
  free(heap);
  heap = NULL;
}
void swap(Heap* heap, int idx1, int idx2){
  if(heap==NULL) return;
  DataValue tmp = heap->nodes[idx1];
  heap->nodes[idx1] = heap->nodes[idx2];
  heap->nodes[idx2] = tmp;
}
int min_idx(Heap* heap, int idx1, int idx2){
  if(heap->nodes[idx1] < heap->nodes[idx2]) return idx1;
  return idx2;
}
void heap_insert(Heap* heap, DataValue data){
  if(heap==NULL) return;
  heap->size++;
  heap->nodes[heap->size] = data;
  for(int idx=heap->size; idx>1; idx=idx/2){
    DataValue cur = heap->nodes[idx];
    DataValue parent = heap->nodes[idx/2];
    if(parent>cur) swap(heap, idx, idx/2);
    else break;
  }
}
DataValue heap_pop(Heap* heap){
  DataValue res = heap->nodes[1];
  swap(heap, 1, heap->size);
  for(int idx=1; idx*2<heap->size; ){
    int next_idx = idx;
    if(idx*2+1<heap->size){
      next_idx = min_idx(heap, idx*2, idx*2+1);
    }
    else if(heap->nodes[idx]>heap->nodes[idx*2]){
      next_idx = idx*2;
    }
    if(heap->nodes[idx] > heap->nodes[next_idx])
      swap(heap, idx, next_idx);
    else break;
    idx = next_idx;
  }
  heap->size--;
  return res;
}
Boolean heap_is_empty(Heap* heap){
  if(heap->size==0) return TRUE;
  return FALSE;
}

void replacement_selection(int* arr, int size, int capacity){
  Heap* heap1 = heap_init();
  Heap* heap2 = heap_init();
  for(int i=0; i<size&&i<capacity; i++) heap_insert(heap1, arr[i]);
  int cur_idx = capacity;
  while(!heap_is_empty(heap1) || !heap_is_empty(heap2)){
    int print_num_count = 0;
    int flag = 0;
    while(!heap_is_empty(heap1)){
      int cur_min = heap_pop(heap1);
      flag = 1;
      if(cur_idx < size){
        int cur_num = arr[cur_idx++];
        if(cur_min < cur_num) heap_insert(heap1, cur_num);
        else heap_insert(heap2, cur_num);
      }
      if(print_num_count++ > 0) printf(" ");
      printf("%d", cur_min);
    }
    if(flag) printf("\n");
    print_num_count = 0;
    flag = 0;
    while(!heap_is_empty(heap2)){
      flag = 1;
      int cur_min = heap_pop(heap2);
      if(cur_idx < size){
        int cur_num = arr[cur_idx++];
        if(cur_min < cur_num) heap_insert(heap2, cur_num);
        else heap_insert(heap1, cur_num);
      }
      if(print_num_count++ > 0) printf(" ");
      printf("%d", cur_min);
    }
    if(flag) printf("\n");
  }
  heap_delete(heap1);
  heap_delete(heap2);
}

int main(int argc, char *argv[]){
  int size, capacity;
  scanf("%d %d", &size, &capacity);
  int arr[MAXN];
  for(int i=0; i<size; i++){
    scanf("%d", &arr[i]);
  }
  replacement_selection(arr, size, capacity);
  return 0;
}
```
